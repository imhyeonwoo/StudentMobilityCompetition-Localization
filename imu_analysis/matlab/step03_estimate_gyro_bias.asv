%% step03_estimate_gyro_bias.m
% 목적: 정지 구간 자동 탐지(짧은 끊김 보정, 최소 길이 적용) → 자이로 바이어스(bx,by,bz) 추정

clear; clc; close all;

%% [경로]
here    = fileparts(mfilename('fullpath'));
outDir  = fullfile(here, '..', 'outputs');
inFile  = fullfile(outDir, 'imu_raw.mat');
if ~exist(inFile,'file'); error('imu_raw.mat이 없습니다. step01을 먼저 실행하세요.'); end
if ~exist(outDir,'dir');  mkdir(outDir); end

%% [로드] (열 벡터 통일)
S  = load(inFile);
t  = S.t(:);        Fs = S.Fs;
gx = S.gx(:); gy = S.gy(:); gz = S.gz(:);
ax = S.ax(:); ay = S.ay(:); az = S.az(:);

%% [파라미터]
g_val        = 9.80665;
th_gyr       = 0.03;          % [rad/s] 0.02→0.05로 완화 (센서 노이즈 고려)
th_acc       = 0.6;           % [m/s^2] g-노름 편차 허용 (짧은 스파이크 무시 용이)
win_sec      = 0.5;           % 이동평균 윈도우(초)
gap_tol_sec  = 1.0;           % 정지 마스크 중간에 0이 이만큼 이하이면 메꿔줌
min_len_sec  = 3.0;          % 이 길이 이상만 정지 구간으로 인정 (사용자: 실제 15초 정지)

Nw = max(1, round(Fs*win_sec));
gap_tol  = max(1, round(Fs*gap_tol_sec));
min_len  = max(1, round(Fs*min_len_sec));

%% [지표] |gyro|, ||a|-g|
gyro_norm = sqrt(gx.^2 + gy.^2 + gz.^2);
acc_norm  = sqrt(ax.^2 + ay.^2 + az.^2);

mov = @(x) movmean(x, Nw, 'Endpoints','shrink');
gyro_s = mov(gyro_norm);
acc_s  = mov(abs(acc_norm - g_val));

is_static_raw = (gyro_s < th_gyr) & (acc_s < th_acc);

%% [스파이크 보정] 짧은 0 구간 메우기 (gap filling)
static_mask = is_static_raw(:);
d = diff([false; static_mask; false]);
starts0 = find(d==-1);  % 1→0 떨어지는 지점+1 = 0구간 시작
ends0   = find(d== 1)-1; % 0→1 올라가기 전 = 0구간 끝
for k = 1:numel(starts0)
    if ends0(k) >= starts0(k) && (ends0(k)-starts0(k)+1) <= gap_tol
        static_mask(starts0(k):ends0(k)) = true;  % 짧은 구멍 메꿈
    end
end

%% [최소 길이] min_len 미만 구간 제거
d2 = diff([false; static_mask; false]);
s1 = find(d2==1); e1 = find(d2==-1)-1;
len1 = e1 - s1 + 1;
keep = len1 >= min_len;
static_mask(:) = false;
for k = find(keep).'
    static_mask(s1(k):e1(k)) = true;
end

%% [가장 긴 정지 구간만 선택] (여러 개면 최장 구간 사용)
d3 = diff([false; static_mask; false]);
s2 = find(d3==1); e2 = find(d3==-1)-1; L = e2 - s2 + 1;
if ~isempty(L)
    [~,imax] = max(L);
    long_mask = false(size(static_mask));
    long_mask(s2(imax):e2(imax)) = true;
    static_mask = long_mask;
end

Ns = nnz(static_mask);
if Ns < min_len
    warning('충분히 긴 정지 구간이 없습니다(N=%d < %d). 파라미터(th_gyr/th_acc/gap_tol/min_len) 조정 필요.', Ns, min_len);
end

%% [바이어스 추정]
bx = mean(gx(static_mask), 'omitnan');
by = mean(gy(static_mask), 'omitnan');
bz = mean(gz(static_mask), 'omitnan');

sx = std(gx(static_mask), 0, 'omitnan');
sy = std(gy(static_mask), 0, 'omitnan');
sz = std(gz(static_mask), 0, 'omitnan');

%% [리포트 저장]
rep = fullfile(outDir,'03_gyro_bias_report.txt');
fid = fopen(rep,'w');
fprintf(fid, "Gyro bias estimate (rad/s)\n");
fprintf(fid, "----------------------------------\n");
fprintf(fid, "bx = %.6f   (std=%.6f)\n", bx, sx);
fprintf(fid, "by = %.6f   (std=%.6f)\n", by, sy);
fprintf(fid, "bz = %.6f   (std=%.6f)\n", bz, sz);
fprintf(fid, "\nSamples used: %d / %d (%.1f%%)\n", Ns, numel(t), 100*Ns/numel(t));
fprintf(fid, "Fs = %.2f Hz\n", Fs);
fprintf(fid, "Params: win=%.2fs, th_gyr=%.5f, th_acc=%.5f, gap_tol=%.2fs, min_len=%.2fs\n", ...
        win_sec, th_gyr, th_acc, gap_tol_sec, min_len_sec);
fclose(fid);
fprintf('Saved report: %s\n', rep);

%% [그림1] 정지 구간 표시
f1 = figure('Name','Static window detection');
subplot(3,1,1);
plot(t, gyro_norm); hold on; yline(th_gyr,'--'); grid on;
ylabel('|gyro| (rad/s)'); title('Static detection signals');
legend('|gyro|','th\_gyr');
subplot(3,1,2);
plot(t, abs(acc_norm - g_val)); hold on; yline(th_acc,'--'); grid on;
ylabel('| |a|-g | (m/s^2)'); legend('| |a|-g |','th\_acc');
subplot(3,1,3);
stairs(t, is_static_raw, 'Color',[.6 .6 .6]); hold on;
stairs(t, static_mask, 'k','LineWidth',1.5);
ylim([-0.1 1.1]); grid on; ylabel('static'); xlabel('Time (s)');
legend('raw static','filled+minlen');

saveas(f1, fullfile(outDir,'03_static_window.png'));

%% [그림2] 바이어스 히스토그램
f2 = figure('Name','Gyro bias histogram');
subplot(3,1,1); histogram(gx(static_mask), 50); grid on;
xlabel('gx (rad/s)'); ylabel('count'); title(sprintf('bx=%.6f, std=%.6f',bx,sx));
subplot(3,1,2); histogram(gy(static_mask), 50); grid on;
xlabel('gy (rad/s)'); ylabel('count'); title(sprintf('by=%.6f, std=%.6f',by,sy));
subplot(3,1,3); histogram(gz(static_mask), 50); grid on;
xlabel('gz (rad/s)'); ylabel('count'); title(sprintf('bz=%.6f, std=%.6f',bz,sz));

saveas(f2, fullfile(outDir,'03_gyro_bias_hist.png'));

%% [저장]
save(fullfile(outDir,'gyro_bias.mat'), ...
     'bx','by','bz','sx','sy','sz','Ns','Fs', ...
     'th_gyr','th_acc','win_sec','gap_tol_sec','min_len_sec','static_mask','-v7.3');

fprintf('Saved: %s\n', fullfile(outDir,'gyro_bias.mat'));
fprintf('Bias [rad/s]: bx=%.6f by=%.6f bz=%.6f  (N=%d, ~%.2fs)\n', ...
        bx, by, bz, Ns, Ns/Fs);
